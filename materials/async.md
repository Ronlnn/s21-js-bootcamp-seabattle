# Асинхронность

JavaScript основан на **однопоточной** модели выполнения, где все операции выполняются в одном потоке. JavaScript как однопоточный язык исполнения не поддерживает параллельное выполнение множества задач в рамках одного процесса.Однако существуют возможности для параллельного выполнения.

## Цикл событий

Цикл событий (Event Loop) — это ключевая часть асинхронной модели выполнения JavaScript. Он управляет обработкой событий и выполнением кода в однопоточной среде.

- Вся программа выполняется внутри стека вызовов. Каждая функция, вызванная в программе, помещается в вершину стека.

- Когда функция выполняется, она может порождать асинхронные операции, такие как таймеры (`setTimeout`), запросы к серверу, обработка событий и т. д.

- Асинхронные операции добавляются в очередь сообщений (message queue) после завершения выполнения стека вызовов.

- Event Loop следит за стеком вызовов и очередью сообщений.Когда стек вызовов пуст, Event Loop берет первое сообщение из очереди и добавляет его в стек вызовов для выполнения.

- Event Loop также управляет очередью микрозадач. Микрозадачи — это функции, которые выполняются после завершения текущей задачи, но до событий ввода-вывода или таймеров.

Работу Event Loop можно схематично преставить так:

![Alt text](image.png)

## Паралелльное выполнение

- ***Web Workers*** представляют собой механизм, позволяющий выполнять JavaScript код в фоновом потоке, параллельно с основным потоком. Но такой механизм имеет ограничения, например, они не имеют доступа к DOM (не только к DOM), но могут выполнять асинхронные операции, обрабатывать сложные вычисления и взаимодействовать с основным потоком через передачу сообщений.

```javascript
// main.js
const worker = new Worker('worker.js'); // путь к файлу
worker.postMessage('Hello from main thread');

// worker.js
onmessage = function (event) {
  console.log('Message received:', event.data);
};

```

- ***Service Workers*** являются специальными видами Web Workers, которые работают в фоновом режиме и могут использоваться для кэширования, уведомлений, и других фоновых задач. Они часто используются в контексте веб-приложений для обработки сетевых запросов и повышения производительности. Например, они используются для создания прогрессивных веб-приложений (PWA), обеспечивая возможность работы оффлайн, улучшенную производительность и другие функциональные возможности.

```javascript
//index.js

// Регистрация сервис-воркера
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/service-worker.js')
      .then((registration) => {
        console.log('Service Worker registered with scope:', registration.scope);
      })
      .catch((error) => {
        console.error('Service Worker registration failed:', error);
      });
  });
}


```

```javascript
//service-worker.js

// Обработчик события установки сервис-воркера
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('my-cache').then((cache) => {
      return cache.addAll([
        '/',
        '/index.html',
        '/styles/main.css',
        '/scripts/main.js',
        '/images/logo.png'
        // Кэшируемые ресурсы (добавляются другие ресурсы, которые нужно закэшировать)
      ]);
    })
  );
});

// Обработчик события активации сервис-воркера
self.addEventListener('activate', (event) => {
  // Выполнение действий после активации сервис-воркера
});

// Обработчик события fetch для обработки запросов
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});

```

- Использование метода ***Promise.all***. Если есть несколько асинхронных задач, которые могут выполняться независимо друг от друга, можно использовать Promise.all для параллельного их выполнения. Promise.all ждет завершения всех переданных промисов и возвращает массив результатов.

```javascript
const promise1 = asyncFunction1();
const promise2 = asyncFunction2();
const promise3 = asyncFunction3();

const results = await Promise.all([promise1, promise2, promise3]);

```

## Использование таймеров

В JavaScript существует несколько таймеров, предоставлемой средой выполнения (Node.js, Браузеры), которые позволяют выполнять код асинхронно или через определенный промежуток времени. Код внутри них становиться макрозадачей.

1. `setTimeout`.  Используется для запуска кода через определенный промежуток времени (в миллисекундах). Возвращает идентификатор таймаута, который можно использовать для отмены запланированного кода с помощью `clearTimeout`.

```javascript
setTimeout(() => {
  console.log('Delayed code');
}, 1000); // Запустить код через 1 секунду

clearTimeout(timeoutId); // При добавлении этой функции, setTimeout отмениться

```

2. `setInterval`. Используется для регулярного запуска кода с интервалом времени. Возвращает идентификатор интервала, который можно использовать для остановки выполнения с помощью `clearInterval`.

```javascript
let counter = 0;
const intervalId = setInterval(() => {
  console.log(`Interval: ${counter}`);
  counter++;

  if (counter === 5) {
    clearInterval(intervalId); // Остановить интервал после 5 вызовов
  }
}, 1000); // Запускать код каждую секунду

 ```

3. `setImmediate`. Используется для того, чтобы поставить функцию в очередь на выполнение без задержки. У `setImmediate` единственный аргумент — это функция, выполнение которой нужно запланировать. ***Внимание: эта функция устарела, и её использование не рекомендуется***. Хотя некоторые браузеры все еще могут ее поддерживать, возможно, она уже удалена из соответствующих веб-стандартов, может находиться в процессе удаления или может быть сохранена только в целях совместимости.

```javascript
setImmediate(() => {
  console.log('Immediate code'); // Запустить код в следующем цикле событий
});

 ```

## Ад обратных вызовов

***Callback hell*** (иногда называется «Pyramid of Doom» из-за визуального представления вложенных колбэков) — это ситуация, когда в асинхронном коде имеется множество вложенных колбэков, что делает код сложным для чтения и поддержки. Это может произойти при использовании колбэков внутри колбэков, что создает глубокие и запутанные структуры.

Пример такой ситуации:

```javascript
function fun1(callback){
    setTimeout(()=>{
    
        let i = 1 ;
        callback(i); i++ ;
        setTimeout(()=>{
     
           callback(i); i++;
           setTimeout(()=>{
        
             callback(i); i++ ;
             setTimeout(()=>{
          
                callback(i); i++ ;
                setTimeout(()=>{
            
                  callback(i); i++ ;
                  // .... and so on
                  
                }, 800)
             }, 700)
           }, 500)
        }, 300)
    }, 100)
}
 ```

Для решения таких проблем были созданы промисы.

## Использование промисов

***Промис (Promise)*** в JavaScript — это объект, представляющий собой асинхронную операцию, которая может завершиться успешно (выполниться) или с ошибкой. Промисы используются для работы с асинхронным кодом, делая его более читаемым и управляемым. Функция обратного вызова. Объект функции с двумя аргументами resolve и reject. Функция executor получает оба аргумента и выполняется сразу, ещё до того как конструктор вернёт созданный объект.

Промис имеет 3 состояния:

- ***Pending (ожидание)***. Начальное состояние, когда промис создан, но результат ещё неизвестен.

- ***Fulfilled (выполнено)***. Промис завершился успешно, и результат доступен.

- ***Rejected (отклонено)***. Промис завершился с ошибкой, и дополнительная информация о ошибке доступна.

```javascript
// Создание промиса
const myPromise = new Promise((resolve, reject) => {
  // Асинхронная операция (например, сетевой запрос)
  const success = true;

  if (success) {
    resolve('Успешное выполнение'); // Вызывается при успешном завершении
  } else {
    reject('Ошибка'); // Вызывается при ошибке
  }
});

// Использование промиса
myPromise
  .then((result) => {
    console.log(result); // Выводит 'Успешное выполнение'
  })
  .catch((error) => {
    console.error(error); // Выводит 'Ошибка'
  });

 ```

Пример порядок вывода

```javascript
console.log('Start');

const myPromise = new Promise((resolve) => {
  console.log('Inside Promise');
  resolve('Promise Resolved');
});

myPromise.then((result) => {
  console.log(result);
});

console.log('End');

//Start
//Inside Promise
//End
//Promise Resolved

 ```

Как видно, `Promise Resolved` вывелся последним. Потому что внутри промиса код выполняется сразу, а `resolve` говорит об успешном завершении промиса, и этот случай мы обрабатываем с помощью цепочки вызовов. Внутри блока `then`, `catch` код становиться микрозадачей, и поэтому он будет выполнен после завершения текущего стека вызовов и перед следующим тактом событий.

### Цепочка вызовов

Цепочка промисов позволяет последовательно выполнять асинхронные операции и обрабатывать их результаты. Он основан на том, что методы `then` и `catch` промиса возвращают новый промис, что позволяет связывать их в цепочки.

```javascript
const promise = new Promise((resolve, reject) => {
  // Асинхронная операция
  setTimeout(() => {
    const success = true;

    if (success) {
      resolve('Успех');
    } else {
      reject('Ошибка');
    }
  }, 1000);
});

promise
  .then((result) => {
    console.log(result); // Выводит 'Успех'
    return 'Дополнительная информация';
  })
  .then((info) => {
    console.log(info); // Выводит 'Дополнительная информация'
    throw new Error('Новая ошибка');
  })
  .catch((error) => {
    console.error(error.message); // Выводит 'Новая ошибка'
  })
  .finally(() => {
    console.log('Выполнится всегда, независимо от результата');
  });

 ```

- В примере выше создается промис с асинхронной операцией (задержкой).
- Метод then обрабатывает успешное завершение промиса, и его результат передается следующему then.
- Во втором then возвращается новый результат, который также передается следующему then.
- Метод catch обрабатывает ошибку, если она возникает где-либо в цепочке.
- Метод finally выполняется вне зависимости от того, была ли успешной или неуспешной цепочка промисов.

Перепишем пример из «Ада обратных вызовов» на промисы. Выглядит уже не так запутано.

```javascript
function promiseFunction(timeout, callback) {
  return new Promise((resolve) => {
    setTimeout(() => {
      let i = 1;
      callback(i);
      i++;
      resolve(i);
    }, timeout);
  });
}

function fun1(callback) {
  promiseFunction(100, callback)
    .then((result) => promiseFunction(300, callback))
    .then((result) => promiseFunction(500, callback))
    .then((result) => promiseFunction(700, callback))
    .then((result) => promiseFunction(800, callback))
    .catch((error) => console.error(error));
}

fun1((value) => console.log(value));

```

### Использование async / await

***async/await*** — это синтаксический сахар в JavaScript, предназначенный для работы с асинхронным кодом. Эти ключевые слова предоставляют удобный и читаемый способ написания кода, который работает асинхронно, но выглядит как синхронный. async используется для определения асинхронной функции, а await используется для ожидания завершения асинхронной операции внутри асинхронной функции. Ключевое слово `async` имеет один простой смысл: эта функция ***всегда возвращает промис***. Значения других типов оборачиваются в завершившийся успешно промис автоматически, и функция, имеющая такое слово, является асинхронной. Ключевое слово `await` заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится. `await` можно использовать только внутри асинхронной функции.

```javascript
function resolveAfter2Seconds() {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve('resolved after 2 seconds');
    }, 2000);
  });
}

async function asyncExample() {
  console.log('Before async operation');
  const result = await resolveAfter2Seconds();
  console.log(result);
  console.log('After async operation');
}

asyncExample();

 ```

Пример из «Ада обратных вызовов» можно переписать так:

```javascript
function promiseFunction(timeout, callback) {
  return new Promise((resolve) => {
    setTimeout(() => {
      let i = 1;
      callback(i);
      i++;
      resolve(i);
    }, timeout);
  });
}

async function fun1(callback) {
  try {
    await promiseFunction(100, callback);
    await promiseFunction(300, callback);
    await promiseFunction(500, callback);
    await promiseFunction(700, callback);
    await promiseFunction(800, callback);
  } catch (error) {
    console.error(error);
  }
}

fun1((value) => console.log(value));

 ```

Написание асинхронного кода с использованием `async / await` является предпочтительным и рекомендуемым.
